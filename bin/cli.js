#!/usr/bin/env node
var g=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports);var f=g((X,C)=>{C.exports={name:"@jackchuka/sdl-decompose",version:"1.1.2",description:"Decompose GraphQL SDL by operation name to produce partial SDL",type:"module",main:"dist/index.js",types:"dist/index.d.ts",scripts:{build:"tsc","build:cli":"node esbuild.config.js",dev:"tsc --watch",test:"jest",prepublishOnly:"npm run build && npm run build:cli"},keywords:["graphql","sdl","decompose","schema"],author:"jackchuka",license:"MIT",repository:{type:"git",url:"https://github.com/jackchuka/sdl-decompose.git"},dependencies:{commander:"^14.0.0",graphql:"^16.8.1"},devDependencies:{"@types/jest":"^30.0.0","@types/node":"^24.0.4",esbuild:"^0.25.5",jest:"^30.0.3","ts-jest":"^29.4.0",typescript:"^5.0.0"},bin:{"sdl-decompose":"bin/cli.js"},files:["dist/**/*","bin/**/*"]}});import{Command as G}from"commander";import{readFileSync as N,writeFileSync as $,existsSync as q}from"fs";import{resolve as I}from"path";import{buildASTSchema as D,parse as T,visit as h,isObjectType as S,isInputObjectType as b,isInterfaceType as L,isUnionType as O,getNamedType as d,printType as j}from"graphql";var v=new Set(["String","Int","Float","Boolean","ID"]);function F(n,t){return t.excludeComments||!t.includeDeprecated?h(n,{FieldDefinition(e){return!t.includeDeprecated&&e.directives&&e.directives.some(s=>s.name.value==="deprecated")?null:t.excludeComments&&e.description?{...e,description:void 0}:e},Directive(e){return e.name.value==="deprecated"&&!t.includeDeprecated?null:e},ObjectTypeDefinition(e){return t.excludeComments&&e.description?{...e,description:void 0}:e},InputObjectTypeDefinition(e){return t.excludeComments&&e.description?{...e,description:void 0}:e},InterfaceTypeDefinition(e){return t.excludeComments&&e.description?{...e,description:void 0}:e},UnionTypeDefinition(e){return t.excludeComments&&e.description?{...e,description:void 0}:e},EnumTypeDefinition(e){return t.excludeComments&&e.description?{...e,description:void 0}:e},ScalarTypeDefinition(e){return t.excludeComments&&e.description?{...e,description:void 0}:e}}):n}function l(n,t,r="query",e={}){try{let i=T(n),s=F(i,e),c=D(s),o={collected:new Set,typeNames:new Set},p=m(c,r);if(!p)return{sdl:"",collectedTypes:new Set,operationFound:!1};let a=p.getFields()[t];return a?(Q(a,o,e),{sdl:x(c,o,r,t,e),collectedTypes:o.typeNames,operationFound:!0}):{sdl:"",collectedTypes:new Set,operationFound:!1}}catch(i){throw new Error(`Failed to decompose GraphQL: ${i instanceof Error?i.message:String(i)}`)}}function m(n,t){switch(t){case"query":return n.getQueryType();case"mutation":return n.getMutationType();case"subscription":return n.getSubscriptionType();default:return null}}function Q(n,t,r){let e=d(n.type);if(u(e,t,r),n.args)for(let i of n.args){let s=d(i.type);u(s,t,r)}}function u(n,t,r){if(!(!n||t.collected.has(n))&&!(!r.includeBuiltinScalars&&v.has(n.name))){if(t.collected.add(n),t.typeNames.add(n.name),S(n)||b(n)){let e=n.getFields();for(let i of Object.values(e)){let s=d(i.type);if(u(s,t,r),"args"in i&&i.args)for(let c of i.args){let o=d(c.type);u(o,t,r)}}}else if(L(n)){let e=n.getFields();for(let i of Object.values(e)){let s=d(i.type);if(u(s,t,r),i.args)for(let c of i.args){let o=d(c.type);u(o,t,r)}}}else if(O(n))for(let e of n.getTypes())u(e,t,r)}}function x(n,t,r,e,i){let s=[],c=m(n,r);if(c){let o=c.getFields()[e];if(o){let p=r==="query"?"Query":r==="mutation"?"Mutation":"Subscription";s.push(`type ${p} {
  ${e}${w(o)}
}`)}}for(let o of t.collected)o.name==="Query"||o.name==="Mutation"||o.name==="Subscription"||s.push(j(o));return s.join(`

`)}function w(n){return`${n.args&&n.args.length>0?`(${n.args.map(r=>`${r.name}: ${r.type}`).join(", ")})`:""}: ${n.type}`}var y=new G;async function E(n){if(n){let r=I(n);if(!q(r))throw new Error(`SDL file not found: ${r}`);return N(r,"utf8")}let t=[];return new Promise((r,e)=>{process.stdin.on("data",i=>{t.push(i)}),process.stdin.on("end",()=>{let i=Buffer.concat(t).toString("utf8");i.trim()?r(i):e(new Error("No SDL content provided via stdin"))}),process.stdin.on("error",e)})}y.name("sdl-decompose").description("Decompose GraphQL SDL by operation name to produce partial SDL").version(f().version).option("-s, --sdl <file>","Path to SDL file (optional, reads from stdin if not provided)").requiredOption("-o, --operation <name>","Operation name to decompose").option("-t, --type <type>","Operation type: query, mutation, subscription","query").option("--output <file>","Output file path (optional, prints to stdout if not provided)").option("--include-builtins","Include builtin scalar types in output",!1).option("--exclude-comments","Remove comments and descriptions from output SDL",!1).option("--include-deprecated","Include deprecated fields in output",!1).action(async n=>{let{sdl:t,operation:r,type:e,output:i,includeBuiltins:s,excludeComments:c,includeDeprecated:o}=n;["query","mutation","subscription"].includes(e)||(console.error("Error: --type must be one of: query, mutation, subscription"),process.exit(1));try{let p=await E(t),a=l(p,r,e,{includeBuiltinScalars:s,excludeComments:c,includeDeprecated:o});a.operationFound||(console.error(`Error: Operation '${r}' not found in ${e} type`),process.exit(1)),i?($(i,a.sdl),console.log(`Decomposed SDL written to: ${i}`),console.log(`Collected types: ${Array.from(a.collectedTypes).join(", ")}`)):console.log(a.sdl)}catch(p){console.error(`Error: ${p instanceof Error?p.message:String(p)}`),process.exit(1)}});y.parse();
